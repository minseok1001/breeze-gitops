# EC2 DevOps 체인 + (향후) EKS GitOps 기본 설정
# - 이 파일은 실행에 사용되는 기본 config.env 입니다.
# - 토큰/패스워드 등 민감 정보는 여기에 직접 넣지 말고(또는 최소화),
#   가능하면 ec2-setup/scripts/gitops/.secrets/ 경로를 사용하세요.
#
# 참고:
# - ec2-setup/scripts/gitops/config.env.example 는 “설명용/예시용”입니다.
# - 이 파일(config.env)은 gitignore 대상이라 커밋되지 않습니다.
#

# =========================
# 공통
# =========================
# 서버 IP(비워두면 자동 감지 시도)
SERVER_IP=""

# 데이터/볼륨 저장 루트(권장: /srv 아래)
DATA_DIR="/srv/gitops-lab"

# 신규 인스턴스에서 자동으로 필수 패키지를 설치할지 여부
# - true : 01_preflight.sh에서 curl/jq/openssl/git 등 설치를 시도(온라인 필요)
# - false: 사용자가 직접 패키지 설치 후 진행
AUTO_INSTALL_PREREQS="true"

# =========================
# 외부 도메인(권장: ALB/Route53 사용 시)
# =========================
# - ALB + Host 기반 라우팅을 이미 구성했다면 아래를 채우세요.
# - 비워두면 스크립트는 SERVER_IP:PORT 기반으로 동작합니다.
GITLAB_EXTERNAL_URL="https://gitops-gitlab.breezelab.io"
HARBOR_EXTERNAL_URL="https://gitops-harbor.breezelab.io"
JENKINS_EXTERNAL_URL="https://gitops-jenkins.breezelab.io"

# (선택) 스크립트가 API 호출에 사용할 내부 URL
# - 같은 EC2에서 실행한다면 보통 localhost:port가 가장 단순합니다.
GITLAB_API_URL="http://127.0.0.1:8080"
HARBOR_API_URL="http://127.0.0.1:8084"
JENKINS_API_URL="http://127.0.0.1:8081"

# =========================
# GitLab (EC2 / 선택: 배포 or 이미 설치됨)
# =========================
# - Git 저장소(소스/매니페스트) 역할
ENABLE_GITLAB="true"
GITLAB_HTTP_PORT="8080"
GITLAB_SSH_PORT="2222"

# GitLab 이미지(버전 고정, latest 금지)
# - Docker Hub 기준 최신(CE, stable) 태그를 사용합니다.
GITLAB_IMAGE="gitlab/gitlab-ce:18.6.2-ce.0"

# (선택) GitLab root 비밀번호를 직접 지정
# - 비워두면 GitLab 기본 동작(초기 비밀번호 파일 생성)을 따르고,
#   스크립트가 기동 후 /etc/gitlab/initial_root_password에서 추출해 .secrets에 저장을 시도합니다.
GITLAB_ROOT_PASSWORD=""

# GitLab 데이터 볼륨 사용 여부
GITLAB_PERSIST_DATA="true"

# GitLab 내부 설정(omnibus) 최소 적용 여부
# - ALB/도메인 기반으로 링크/클론 URL을 맞추려면 true 권장
GITLAB_APPLY_OMNIBUS_CONFIG="true"

# GitLab 초기 기동 대기 시간(초)
GITLAB_STARTUP_TIMEOUT_SEC="1800"
# GitLab 컨테이너 /dev/shm 크기
GITLAB_SHM_SIZE="1g"

# GitLab API 자동화 토큰(PAT, api scope)
# - 데모 리포 생성/시드/웹훅 등록에 필요
# - 생성 URL 예:
#   https://gitops-gitlab.breezelab.io/-/user_settings/personal_access_tokens
# - 권장: name=bootstrap, scope=api
GITLAB_TOKEN=""
GITLAB_GROUP_PATH=""          # 예: "lab" (비우면 사용자 네임스페이스)

# =========================
# Harbor (EC2 / 선택: 배포 or 이미 설치됨)
# =========================
# - 이미지 레지스트리 역할
ENABLE_HARBOR="true"
HARBOR_HTTP_PORT="8084"
# Harbor 설치 프로토콜
# - 기본값: http (ALB가 HTTPS를 종료하는 구조에서 가장 단순)
# - https를 쓰려면 Harbor 내부 인증서(ssl_cert 등) 설정이 추가로 필요할 수 있습니다.
HARBOR_PROTOCOL="http"
# (선택) HARBOR_PROTOCOL=https 일 때만 사용
HARBOR_HTTPS_PORT="443"
HARBOR_SSL_CERT_PATH=""   # 예: /etc/ssl/certs/harbor.crt
HARBOR_SSL_KEY_PATH=""    # 예: /etc/ssl/private/harbor.key

# 레지스트리 주소(host:port)
# - ALB(443)로 레지스트리를 노출한다면 보통 "gitops-harbor.breezelab.io" 처럼 포트 없이 사용합니다.
HARBOR_REGISTRY_HOSTPORT="gitops-harbor.breezelab.io"

# Harbor 오프라인 설치 번들 경로(tgz).
# - 기본값은 GitHub 릴리즈에서 v2.14.1 tgz를 다운로드해서 사용합니다.
# - 폐쇄망이면 아래 URL 다운로드가 실패할 수 있으니, 파일을 수동 반입 후 PATH만 지정하세요.
HARBOR_OFFLINE_TGZ_URL="https://github.com/goharbor/harbor/releases/download/v2.14.1/harbor-offline-installer-v2.14.1.tgz"
# - 비워두면 스크립트가 ec2-setup/scripts/gitops/.state/ 아래를 먼저 탐색하고, 없으면 다운로드 후 사용합니다.
HARBOR_OFFLINE_TGZ_PATH=""

# Harbor 관리자 계정(프로젝트/robot 생성용)
HARBOR_ADMIN_USER="admin"
HARBOR_ADMIN_PASSWORD=""

# 파이프라인에서 사용할 Harbor 프로젝트/로봇 계정
HARBOR_PROJECT_NAME="demo"
HARBOR_ROBOT_NAME="jenkins"

# =========================
# Jenkins (EC2 / 선택: 배포 or 이미 설치됨)
# =========================
# - CI 엔진 역할(GitLab Webhook → Jenkins 빌드 → Harbor push)
ENABLE_JENKINS="true"
JENKINS_HTTP_PORT="8081"

# Jenkins 이미지(버전 고정, latest 금지) - 05_deploy_jenkins.sh에서 사용
JENKINS_IMAGE="jenkins/jenkins:2.528.3-lts-jdk17"
JENKINS_PERSIST_DATA="true"
JENKINS_ENABLE_DOCKER_SOCKET="true"

# Jenkins API 인증(08 스크립트에서 필요)
# - Jenkins에서 사용자 API Token 생성 후 입력
JENKINS_USER=""
JENKINS_API_TOKEN=""

# GitLab Webhook이 Jenkins를 트리거할 때 사용할 방식(09 스크립트)
# - 기본값(false) : /job/<job>/build?token=... (Jenkins 보안 설정에 따라 403이 날 수 있음)
# - true          : URL에 Basic Auth(user:apitoken@)를 포함(POC에서만 권장, URL에 토큰이 노출됨)
JENKINS_WEBHOOK_USE_BASIC_AUTH="false"
JENKINS_WEBHOOK_USER=""      # 비우면 JENKINS_USER 사용
JENKINS_WEBHOOK_PASS=""      # 비우면 JENKINS_API_TOKEN 사용

# (선택) Build Authorization Token Root Plugin을 쓰는 방식
# - true면 /buildByToken/build?job=...&token=... 를 사용(플러그인 필요)
JENKINS_WEBHOOK_USE_BUILD_BY_TOKEN="false"

# GitLab Webhook SSL 검증(도메인이 정상 인증서면 true 권장)
GITLAB_WEBHOOK_ENABLE_SSL_VERIFICATION="true"

# 파이프라인 Jenkins Job 이름(기본 demo-app)
JENKINS_JOB_NAME="demo-app"
# (선택) 잡 원격 트리거 토큰. 비워두면 08 스크립트가 생성해서 .secrets에 저장
JENKINS_JOB_TOKEN=""

# =========================
# 파이프라인 데모 리포(07 스크립트)
# =========================
PIPELINE_REPO_NAME="demo-app"
PIPELINE_REPO_PATH="demo-app"
PIPELINE_DEFAULT_BRANCH="main"

# Jenkinsfile/Dockerfile에 들어갈 앱 이름/베이스 이미지(버전 고정)
PIPELINE_APP_NAME="demo-app"
PIPELINE_BASE_IMAGE="nginx:1.29.4-alpine"

# =========================
# 검증(10 스크립트)
# =========================
# - true면 10_verify.sh에서 Jenkins 빌드를 실제로 트리거합니다.
VERIFY_TRIGGER_BUILD="true"
